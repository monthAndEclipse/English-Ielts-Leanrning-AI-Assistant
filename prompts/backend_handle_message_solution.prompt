==================================================================================
handle_translation_request是我接收完rabbitmq消息之后的处理方法，因为是个耗时任务，所以我想改造一下
，接收后检查payload，然后立即入库，入库成功之后，立即开一个新的线程处理剩余的逻辑，请帮我改造下
我使用python+ fastapi +asyncio的

```code 
from app.schemas.mq_schema import TranslationRequest,EventType,TranslationResult
import logging
from app.llm_client.factory import get_llm_client
from app.config import get_settings
from app.db.database import get_session
from app.services.db.translation_task_service import create_translation_task,update_translation_complete,update_translation_start
from app.utils.storage_utils import download_file_text_from_storage,upload_file_to_storage
from app.utils.texts_utils import split_json_chunks,format_prompts
import json
from typing import List, Dict, Any,Set
import asyncio
from app.mq.service_manager import service_manager
from datetime import datetime

logger = logging.getLogger(__name__)

class TranslateService:

    # 定义消息处理函数
    def __init__(self):
        self.db_session = None
        self.settings = None
        self.client = None

    # 处理翻译逻辑
    async def translate_wrapper(self,payload: TranslationRequest):
        task_id = payload.uuid
        self.settings = get_settings()
        self.client = get_llm_client(self.settings.llm_default_provider, self.settings.llm_default_model)
        self.db_session = get_session()
        try:
            # 步骤1: 创建任务记录
            create_translation_task(self.db_session,payload)
            # 步骤2: 下载并解析内容文件
            original_json = await download_file_text_from_storage(payload.file_path,payload.jwt)
            if not original_json:
                update_translation_complete(self.db_session,task_id, error_message="内容文件为空")
                return False
            #切割
            chunks = split_json_chunks(original_json,self.settings.llm_prompt_max_chars)
            if not chunks:
                update_translation_complete(self.db_session,task_id, error_message="文本切割后为空")
                return False
            #拼成一个个成品prompt
            prompts = format_prompts(chunks, payload.prompt_template)
            logger.debug(f"开始并发翻译，更新数据库状态")
            update_translation_start(self.db_session,task_id)
            #并发翻译
            translated_contents = await self.translate_large_text(prompts)
            #填回原内容
            original_json["texts"]= translated_contents
            #转成字符数组上传
            object_info = await upload_file_to_storage(payload.jwt,"files",bytes(original_json),payload.filename)
            #更新数据库
            update_translation_complete(self.db_session,task_id, file_path=object_info.file_path)
            #发送完成的消息到mq
            result = TranslationResult(
                uuid=payload.uuid,
                jwt=payload.jwt,
                file_path=payload.file_path,
                translation_end_time=datetime.now()
            )
            service_manager.publish_translation_result(EventType.DOC_TRANSLATION,result)
            logger.info(f"翻译任务完成: {task_id}")
            return True

        except Exception as e:
            logger.error(f"翻译任务处理失败: {task_id}, 错误: {e}")
            update_translation_complete(self.db_session,task_id, error_message=str(e))
            return False



    async def translate_large_text(self,prompts:List[str]):
        max_concurrent_tasks = int(self.settings.llm_max_concurrent_task)
        semaphore = asyncio.Semaphore(max_concurrent_tasks)
        tasks = [
            self.translate_prompt_with_semaphore(prompt, semaphore)
            for prompt in prompts
        ]
        translated_prompts = await asyncio.gather(*tasks)
        # 合并翻译结果
        final_result = []
        for prompt_result in translated_prompts:
            try:
                # 每个prompt_result是一个包含 "translation" 字段的JSON字符串
                parsed = json.loads(prompt_result)
                final_result.extend(parsed.get("translation", []))
            except json.JSONDecodeError as e:
                logger.error(f"解析失败：{prompt_result}")
                #有一个失败说明某一段其实没翻译完成，其实也算整体失败了，继续往外抛
                raise e
        return final_result


    # 加上 semaphore 的受控任务
    async def translate_prompt_with_semaphore(self,prompt, semaphore):
        async with semaphore:
            return await self.retry_translate(prompt)

    # 异步重试逻辑
    async def retry_translate(self,prompt):
        retries =  int(self.settings.llm_max_retries)
        retry_delay =  int(self.settings.llm_retry_delay)
        for attempt in range(1, retries + 1):
            try:
                result = await asyncio.to_thread(self.client.translate,prompt)
                return result
            except Exception as e:
                logger.error(f"翻译失败（尝试 {attempt}/{retries}）：{e}")
                logger.exception(f"翻译失败详情")
                if attempt < retries:
                    retry_delay = int(retry_delay)
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    #继续向外抛
                    raise e
        return None


async def handle_translation_request(request: TranslationRequest) -> None:
    await TranslateService().translate_wrapper(request)
```
