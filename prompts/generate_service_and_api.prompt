==================================================================================
ç†è§£ä¸‹é¢çš„æ–¹æ¡ˆï¼Œå¹¶å…ˆå¸®æˆ‘ç»™å‡ºåç«¯pythonserviceå’Œrouter
è¯´æ˜ï¼š
0. å¸®æˆ‘å®ç°serviceå±‚å¯¹å­˜å‚¨ç±»æŠ½è±¡çš„å°è£…ä»¥åŠå¯¹åº”routerå±‚å®ç°
1. å·²ç»å®ç°äº†çš„éƒ¨åˆ†ï¼šå­˜å‚¨ç±»çš„æŠ½è±¡å’Œminioçš„å…·ä½“å®ç°ï¼Œä»¥åŠå·¥å‚ç±»(ä»£ç ä¸‹é¢ä¼šç»™å‡º)
2. æš‚æ—¶ä¸éœ€è¦å®ç°çš„éƒ¨åˆ†ï¼šå‰ç«¯æš‚æ—¶ä¸éœ€è¦ï¼Œä»£ç ä½¿ç”¨ç¤ºä¾‹ä¹Ÿä¸éœ€è¦ï¼Œpostgresç›¸å…³çš„ä¹Ÿä¸ç”¨ï¼Œ
3. ä»£ç è´¨é‡è¦é«˜,ä¸è¦å…¨éƒ¨ä»£ç å†™åœ¨ä¸€èµ·ï¼Œè¦åˆ†æ–‡ä»¶ï¼Œè¿™ä¸ªå¯è¯»æ€§é«˜ï¼Œåé¢å¥½ç»´æŠ¤


# pyå­˜å‚¨æœåŠ¡è§£å†³æ–¹æ¡ˆ
## ç›®æ ‡
å®ç°ç»Ÿä¸€å°è£…ï¼Œæš´éœ²æ¥å£ç»™åˆ°å…¶ä»–æœåŠ¡ä½¿ç”¨ï¼Œç›®å‰åªéœ€è¦æ”¯æŒåˆ°minio,ä½†æ•´ä½“ä»£ç æ¶æ„éœ€è¦æ”¯æŒåæœŸå¾ˆçµæ´»çš„æ·»åŠ ï¼Œæ‰€ä»¥éœ€è¦ç»Ÿä¸€æŠ½è±¡*
## åç«¯åŒ…å«çš„èƒ½åŠ›
âœ… æ–‡ä»¶ä¸Šä¼ ï¼ˆæœ¬åœ°æ–‡ä»¶ + æ•°æ®æµ + urlï¼‰
âœ… æ–‡ä»¶ä¸‹è½½å’Œæ•°æ®è·å–
âœ… æ–‡ä»¶åˆ é™¤ï¼ˆå•ä¸ª + æ‰¹é‡ï¼‰
âœ… æ–‡ä»¶åˆ—è¡¨å’Œä¿¡æ¯æŸ¥è¯¢
âœ… é¢„ç­¾åURLç”Ÿæˆï¼ˆè®¿é—® + ä¸Šä¼ ï¼‰
âœ… æ–‡ä»¶å¤åˆ¶å’Œå­˜å‚¨æ¡¶ç®¡ç†
âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
âœ… postgresæ•°æ®åº“è®°å½•ç›¸å…³æ“ä½œ
## æ„æ¶
python + FastApi + next.js + docker(åæœŸè½¬k8s)
## é—®é¢˜
### éœ€ä¸éœ€è¦å¸¦ç”¨æˆ·ä¿¡æ¯ï¼Ÿæˆ–è€…è¯´ï¼Œå“ªä¸€è¾¹æ¥åšè·¯å¾„çš„æ‹¼æ¥ï¼Ÿ
ç­”ï¼šéœ€è¦å¸¦çš„ï¼Œè€Œä¸”è·¯å¾„çš„æ‹¼æ¥è¦ç”±å­˜å‚¨æœåŠ¡æ¥åš
ğŸ” åŸå› è¯¦è§£ï¼š
âœ… 1. èŒè´£å•ä¸€ï¼šå‰ç«¯/ä¸šåŠ¡æœåŠ¡ä¸åº”å…³å¿ƒè·¯å¾„è§„åˆ™
å¦‚æœå‰ç«¯æˆ–ä¸šåŠ¡æœåŠ¡æ‹¼è·¯å¾„ï¼Œé‚£ä¹ˆè·¯å¾„è§„åˆ™ä¸€æ—¦ä¿®æ”¹ï¼ˆæ¯”å¦‚ user-123/files/xxx.png â†’ u123/uploads/yyyy.pngï¼‰ï¼Œæ‰€æœ‰æœåŠ¡éƒ½è¦ä¿®æ”¹ï¼›
ä¼šå¯¼è‡´ã€Œè·¯å¾„è§„åˆ™æ‰©æ•£ã€ä¸ã€Œå¼ºè€¦åˆã€ã€‚

âœ… 2. è·¯å¾„è§„åˆ™ç»Ÿä¸€æ›´æ˜“ç»´æŠ¤å’Œæ‰©å±•
å¦‚æœè·¯å¾„æ‹¼æ¥é€»è¾‘ç»Ÿä¸€å†™åœ¨å­˜å‚¨æœåŠ¡ä¸­ï¼Œå°±å¯ä»¥ï¼š
åŠ å‰ç¼€å¦‚ user_id/
åŠ æ—¶é—´å¦‚ 20250615/user_id/filename
åŠ ä¸šåŠ¡åˆ†ç±»å¦‚ user_id/avatar/ æˆ– user_id/docs/
è¿™äº›é€»è¾‘éƒ½å¯ä»¥é›†ä¸­åœ¨ä¸€ä¸ªè·¯å¾„ç”Ÿæˆå‡½æ•°é‡Œï¼Œæœªæ¥çµæ´»æ”¹åŠ¨ã€‚

âœ… 3. æƒé™ä¸å®¡è®¡ä¹Ÿå¯ä»¥ç»Ÿä¸€åš
å¦‚æœç”±å­˜å‚¨æœåŠ¡æ‹¼è·¯å¾„ï¼Œå®ƒå¯ä»¥é¡ºä¾¿åšä¸€äº›åˆ¤æ–­ï¼š
user_id æ˜¯å¦æœ‰æ•ˆï¼Ÿ
å½“å‰ç”¨æˆ·æ˜¯å¦æœ‰å†™æƒé™ï¼Ÿ
æ˜¯å¦è¶…è¿‡é…é¢ï¼Ÿ

âœ… 4. éšè— MinIOç­‰ä¸‰æ–¹å­˜å‚¨å®ç°ç»†èŠ‚
ä½ å¯ä»¥å†…éƒ¨é‡‡ç”¨ MinIO è·¯å¾„è§„åˆ™ã€æ–‡ä»¶åç¼€åã€UUIDå‘½åç­‰æ–¹å¼ï¼Œè€Œå¤–éƒ¨æœåŠ¡æ— éœ€å…³å¿ƒã€‚

ğŸ”’ æƒé™æ§åˆ¶å»ºè®®ï¼š
å¦‚æœä½ æ‹…å¿ƒâ€œè®©å­˜å‚¨æœåŠ¡æ‹¼è·¯å¾„â€ä¼šè®©è°ƒç”¨æœåŠ¡è§‰å¾—æƒé™æ§åˆ¶ä¸é€æ˜ï¼Œå¯ä»¥ï¼š
ä½¿ç”¨ç­¾åURLï¼šæƒé™ç”±ç­¾åæ§åˆ¶ï¼›
è¦æ±‚ä¼  token / user_idï¼Œä½ æœåŠ¡æ ¡éªŒï¼›
æˆ–è€…ä»…é™å—ä¿¡æœåŠ¡ä¹‹é—´è°ƒç”¨ï¼ˆèµ°å†…éƒ¨ç½‘ç»œ + JWTï¼‰

### ç”¨æˆ·ä¿¡æ¯ç›®å‰æ€ä¹ˆä¼ é€’ï¼Ÿ
ç›®å‰ä½¿ç”¨çš„è®¤è¯æ˜¯supabaseçš„ï¼Œå‰ç«¯ç™»å½•å®Œä¹‹åè°ƒç”¨åç«¯æ¥å£ä¼šæºå¸¦jwt token, æ‹¿åˆ°token
ç›´æ¥å»åˆ°supabase-auth-serviceé‡Œé¢å…ˆéªŒè¯ä¸€éï¼Œæœ‰æ•ˆå°±è·å–ç”¨æˆ·ä¿¡æ¯ã€‚
å¼€å§‹æ‹¼æ¥æ–‡ä»¶è·¯å¾„ï¼Œæ— è®ºpreSignUploadUrlç›´è¿å­˜å‚¨ä¹Ÿå¥½ï¼Œè¿˜æ˜¯ç›´æ¥é€šè¿‡cloud-storage-serviceå¤šä¸€æ­¥ä¸Šä¼ ä¹Ÿå¥½
éƒ½åœ¨è¿™é‡Œæ§åˆ¶è·¯å¾„æ ¼å¼ã€‚


## ä»£ç 
app/core/cloud_storage_base.py
```python
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Union, BinaryIO
from datetime import datetime, timedelta
from io import BytesIO
from ..schemas.storage import FileInfo, PresignedUrlResponse, FileDownloadResponse

class BaseStorageProvider(ABC):
    """å­˜å‚¨æä¾›å•†åŸºç¡€æ¥å£"""

    def __init__(self, config: dict):
        self.config = config
        self.client = None

    @abstractmethod
    async def initialize(self) -> None:
        """åˆå§‹åŒ–å­˜å‚¨å®¢æˆ·ç«¯"""
        pass

    @abstractmethod
    async def upload_file(
            self,
            file_path: str,
            file_data: Union[bytes, BinaryIO, BytesIO],
            content_type: Optional[str] = None,
            metadata: Optional[Dict[str, str]] = None
    ) -> FileInfo:
        """
        ä¸Šä¼ æ–‡ä»¶
        Args:
            file_path: å­˜å‚¨è·¯å¾„
            file_data: æ–‡ä»¶æ•°æ®
            content_type: æ–‡ä»¶ç±»å‹
            metadata: æ–‡ä»¶å…ƒæ•°æ®
        Returns:
            FileInfo: æ–‡ä»¶ä¿¡æ¯
        """
        pass

    @abstractmethod
    async def upload_from_url(
            self,
            file_path: str,
            url: str,
            content_type: Optional[str] = None,
            metadata: Optional[Dict[str, str]] = None
    ) -> FileInfo:
        """
        ä»URLä¸Šä¼ æ–‡ä»¶
        Args:
            file_path: å­˜å‚¨è·¯å¾„
            url: æºæ–‡ä»¶URL
            content_type: æ–‡ä»¶ç±»å‹
            metadata: æ–‡ä»¶å…ƒæ•°æ®
        Returns:
            FileInfo: æ–‡ä»¶ä¿¡æ¯
        """
        pass

    @abstractmethod
    async def download_file(self, file_path: str) -> bytes:
        """
        ä¸‹è½½æ–‡ä»¶æ•°æ®
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
        Returns:
            bytes: æ–‡ä»¶æ•°æ®
        """
        pass

    @abstractmethod
    async def get_file_info(self, file_path: str) -> FileInfo:
        """
        è·å–æ–‡ä»¶ä¿¡æ¯
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
        Returns:
            FileInfo: æ–‡ä»¶ä¿¡æ¯
        """
        pass

    @abstractmethod
    async def delete_file(self, file_path: str) -> bool:
        """
        åˆ é™¤å•ä¸ªæ–‡ä»¶
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
        Returns:
            bool: æ˜¯å¦åˆ é™¤æˆåŠŸ
        """
        pass

    @abstractmethod
    async def delete_files(self, file_paths: List[str]) -> Dict[str, bool]:
        """
        æ‰¹é‡åˆ é™¤æ–‡ä»¶
        Args:
            file_paths: æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        Returns:
            Dict[str, bool]: æ–‡ä»¶è·¯å¾„ -> æ˜¯å¦åˆ é™¤æˆåŠŸçš„æ˜ å°„
        """
        pass

    @abstractmethod
    async def list_files(
            self,
            prefix: Optional[str] = None,
            limit: int = 100,
            start_after: Optional[str] = None
    ) -> List[FileInfo]:
        """
        åˆ—å‡ºæ–‡ä»¶
        Args:
            prefix: è·¯å¾„å‰ç¼€
            limit: è¿”å›æ•°é‡é™åˆ¶
            start_after: èµ·å§‹ä½ç½®

        Returns:
            List[FileInfo]: æ–‡ä»¶ä¿¡æ¯åˆ—è¡¨
        """
        pass

    @abstractmethod
    async def file_exists(self, file_path: str) -> bool:
        """
        æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
        Returns:
            bool: æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        """
        pass

    @abstractmethod
    async def copy_file(
            self,
            source_path: str,
            target_path: str,
            metadata: Optional[Dict[str, str]] = None
    ) -> FileInfo:
        """
        å¤åˆ¶æ–‡ä»¶
        Args:
            source_path: æºæ–‡ä»¶è·¯å¾„
            target_path: ç›®æ ‡æ–‡ä»¶è·¯å¾„
            metadata: æ–°æ–‡ä»¶å…ƒæ•°æ®
        Returns:
            FileInfo: æ–°æ–‡ä»¶ä¿¡æ¯
        """
        pass

    @abstractmethod
    async def generate_presigned_upload_url(
            self,
            file_path: str,
            content_type: Optional[str] = None,
            expire_seconds: int = 3600
    ) -> PresignedUrlResponse:
        """
        ç”Ÿæˆé¢„ç­¾åä¸Šä¼ URL
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
            content_type: æ–‡ä»¶ç±»å‹
            expire_seconds: è¿‡æœŸæ—¶é—´(ç§’)
        Returns:
            PresignedUrlResponse: é¢„ç­¾åURLä¿¡æ¯
        """
        pass

    @abstractmethod
    async def generate_presigned_download_url(
            self,
            file_path: str,
            expire_seconds: int = 3600
    ) -> FileDownloadResponse:
        """
        ç”Ÿæˆé¢„ç­¾åä¸‹è½½URL
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
            expire_seconds: è¿‡æœŸæ—¶é—´(ç§’)
        Returns:
            FileDownloadResponse: ä¸‹è½½URLä¿¡æ¯
        """
        pass

    @abstractmethod
    async def create_bucket(self, bucket_name: str) -> bool:
        """
        åˆ›å»ºå­˜å‚¨æ¡¶
        Args:
            bucket_name: å­˜å‚¨æ¡¶åç§°
        Returns:
            bool: æ˜¯å¦åˆ›å»ºæˆåŠŸ
        """
        pass

    @abstractmethod
    async def bucket_exists(self, bucket_name: str) -> bool:
        """
        æ£€æŸ¥å­˜å‚¨æ¡¶æ˜¯å¦å­˜åœ¨
        Args:
            bucket_name: å­˜å‚¨æ¡¶åç§°
        Returns:
            bool: å­˜å‚¨æ¡¶æ˜¯å¦å­˜åœ¨
        """
        pass

    @abstractmethod
    async def get_storage_stats(self, prefix: Optional[str] = None) -> Dict[str, Union[int, float]]:
        """
        è·å–å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
        Args:
            prefix: è·¯å¾„å‰ç¼€
        Returns:
            Dict: ç»Ÿè®¡ä¿¡æ¯ (total_files, total_size, etc.)
        """
        pass
```
app/factory/storage_factory.py
```python
from typing import Dict, Type

from app.core.cloud_storage_base import BaseStorageProvider
from app.core.impl.minio_storage import MinIOStorageProvider
from app.config import StorageProvider
from app.exceptions import StorageOperationException
from app.utils.logger import get_logger
from app.config import get_settings
logger = get_logger(__name__)


class StorageFactory:
    """å­˜å‚¨æä¾›å•†å·¥å‚ç±»"""

    # æ³¨å†Œæ‰€æœ‰å¯ç”¨çš„å­˜å‚¨æä¾›å•†
    _providers: Dict[StorageProvider, Type[BaseStorageProvider]] = {
        StorageProvider.MINIO: MinIOStorageProvider,
        # æœªæ¥å¯ä»¥æ·»åŠ æ›´å¤šæä¾›å•†:
        # StorageProvider.AWS_S3: S3StorageProvider,
        # StorageProvider.GOOGLE_CLOUD: GCSStorageProvider,
    }
    # å­˜å‚¨æä¾›å•†å®ä¾‹ç¼“å­˜
    _instances: Dict[StorageProvider, BaseStorageProvider] = {}

    @classmethod
    async def get_storage_provider(cls, provider_type: StorageProvider = None) -> BaseStorageProvider:
        """
        è·å–å­˜å‚¨æä¾›å•†å®ä¾‹

        Args:
            provider_type: å­˜å‚¨æä¾›å•†ç±»å‹ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é…ç½®ä¸­çš„é»˜è®¤ç±»å‹

        Returns:
            BaseStorageProvider: å­˜å‚¨æä¾›å•†å®ä¾‹
        """
        settings = get_settings()
        if provider_type is None:
            provider_type = settings.storage_provider

        # æ£€æŸ¥æ˜¯å¦å·²ç»åˆ›å»ºäº†å®ä¾‹
        if provider_type in cls._instances:
            return cls._instances[provider_type]

        # æ£€æŸ¥æä¾›å•†æ˜¯å¦å·²æ³¨å†Œ
        if provider_type not in cls._providers:
            available_providers = ", ".join([p.value for p in cls._providers.keys()])
            raise StorageOperationException(
                "factory",
                f"Unsupported storage provider: {provider_type}. "
                f"Available providers: {available_providers}"
            )

        # åˆ›å»ºé…ç½®
        config = cls._get_provider_config(provider_type)

        # åˆ›å»ºå®ä¾‹
        provider_class = cls._providers[provider_type]
        provider_instance = provider_class(config)

        # åˆå§‹åŒ–
        await provider_instance.initialize()

        # ç¼“å­˜å®ä¾‹
        cls._instances[provider_type] = provider_instance

        logger.info(f"Storage provider '{provider_type}' initialized successfully")

        return provider_instance

    @classmethod
    def _get_provider_config(cls, provider_type: StorageProvider) -> dict:
        """
        æ ¹æ®æä¾›å•†ç±»å‹è·å–é…ç½®

        Args:
            provider_type: å­˜å‚¨æä¾›å•†ç±»å‹

        Returns:
            dict: æä¾›å•†é…ç½®
        """
        settings = get_settings()
        if provider_type == StorageProvider.MINIO:
            return {
                "endpoint": settings.minio_endpoint,
                "access_key": settings.minio_access_key,
                "secret_key": settings.minio_secret_key,
                "secure": settings.minio_secure,
                "bucket_name": settings.minio_bucket_name,
            }

        # æœªæ¥å¯ä»¥æ·»åŠ å…¶ä»–æä¾›å•†çš„é…ç½®
        # elif provider_type == StorageProvider.AWS_S3:
        #     return {
        #         "region": settings.aws_region,
        #         "access_key_id": settings.aws_access_key_id,
        #         "secret_access_key": settings.aws_secret_access_key,
        #         "bucket_name": settings.aws_bucket_name,
        #     }

        raise StorageOperationException(
            "factory",
            f"No configuration found for storage provider: {provider_type}"
        )

    @classmethod
    def register_provider(
            cls,
            provider_type: StorageProvider,
            provider_class: Type[BaseStorageProvider]
    ) -> None:
        """
        æ³¨å†Œæ–°çš„å­˜å‚¨æä¾›å•†

        Args:
            provider_type: å­˜å‚¨æä¾›å•†ç±»å‹
            provider_class: å­˜å‚¨æä¾›å•†ç±»
        """
        cls._providers[provider_type] = provider_class
        logger.info(f"Storage provider '{provider_type}' registered successfully")

    @classmethod
    def get_available_providers(cls) -> list[str]:
        """
        è·å–æ‰€æœ‰å¯ç”¨çš„å­˜å‚¨æä¾›å•†

        Returns:
            list[str]: å¯ç”¨æä¾›å•†åˆ—è¡¨
        """
        return [provider.value for provider in cls._providers.keys()]

    @classmethod
    async def close_all_connections(cls) -> None:
        """å…³é—­æ‰€æœ‰å­˜å‚¨æä¾›å•†è¿æ¥"""
        for provider_type, instance in cls._instances.items():
            try:
                if hasattr(instance, 'close'):
                    await instance.close()
                logger.info(f"Closed connection for storage provider: {provider_type}")
            except Exception as e:
                logger.error(f"Error closing storage provider {provider_type}: {str(e)}")

        cls._instances.clear()


# ä¾¿æ·å‡½æ•°
async def get_default_storage() -> BaseStorageProvider:
    """è·å–é»˜è®¤å­˜å‚¨æä¾›å•†å®ä¾‹"""
    return await StorageFactory.get_storage_provider()
```
==================================================================================