==================================================================================
理解下面的方案，并先帮我给出后端python（## 后端包含的能力）相关实现，
前端暂时不需要，代码使用示例也不需要，postgres的也不用先，需要给个骨架,代码质量要高,不要全部代码写在一起。
要分文件，这个可读性高，后面好维护


# py存储服务解决方案

## 目标
实现统一封装，暴露接口给到其他服务使用，目前只需要支持到minio,但整体代码架构需要支持后期很灵活的添加，所以需要统一抽象

## 后端包含的能力
✅ 文件上传（本地文件 + 数据流 + url）
✅ 文件下载和数据获取
✅ 文件删除（单个 + 批量）
✅ 文件列表和信息查询
✅ 预签名URL生成（访问 + 上传）
✅ 文件复制和存储桶管理
✅ 完整的错误处理和日志记录
✅ postgres数据库记录相关操作

## 前端简单列表查询


## 构架
python + FastApi + next.js + docker(后期转k8s)

## 问题
### 需不需要带用户信息？或者说，哪一边来做路径的拼接？
答：需要带的，而且路径的拼接要由存储服务来做
🔍 原因详解：
✅ 1. 职责单一：前端/业务服务不应关心路径规则
如果前端或业务服务拼路径，那么路径规则一旦修改（比如 user-123/files/xxx.png → u123/uploads/yyyy.png），所有服务都要修改；
会导致「路径规则扩散」与「强耦合」。

✅ 2. 路径规则统一更易维护和扩展
如果路径拼接逻辑统一写在存储服务中，就可以：
加前缀如 user_id/
加时间如 20250615/user_id/filename
加业务分类如 user_id/avatar/ 或 user_id/docs/
这些逻辑都可以集中在一个路径生成函数里，未来灵活改动。

✅ 3. 权限与审计也可以统一做
如果由存储服务拼路径，它可以顺便做一些判断：
user_id 是否有效？
当前用户是否有写权限？
是否超过配额？

✅ 4. 隐藏 MinIO等三方存储实现细节
你可以内部采用 MinIO 路径规则、文件后缀名、UUID命名等方式，而外部服务无需关心。

🔒 权限控制建议：
如果你担心“让存储服务拼路径”会让调用服务觉得权限控制不透明，可以：
使用签名URL：权限由签名控制；
要求传 token / user_id，你服务校验；
或者仅限受信服务之间调用（走内部网络 + JWT）

### 用户信息目前怎么传递？
目前使用的认证是supabase的，前端登录完之后调用后端接口会携带jwt token, 拿到token
直接去到supabase-auth-service里面先验证一遍，有效就获取用户信息。
开始拼接文件路径，无论preSignUploadUrl直连存储也好，还是直接通过cloud-storage-service多一步上传也好
都在这里控制路径格式。
==================================================================================